<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kubernetes安装istio]]></title>
    <url>%2F2018%2F07%2F10%2Fnew-to-istio%2F</url>
    <content type="text"><![CDATA[下载Istio下载最新版的istio1curl -L https://git.io/getLatestIstio | sh - 12cd istio-0.8.0export PATH=$PWD/bin:$PATH 安装文件在install目录下，istioctl执行文件在bin目录下，一些应用在samples目录下 安装Istio1kubectl apply -f install/kubernetes/istio-demo.yaml 由于我用的是docker-for-mac，我的kubernetes是没有Loadbalancer的，所以我把istio-demo.yaml文件里的LoadBalancer改成了NodePort 验证Istio查看service和pod是否都正常运行 部署应用部署应用有两种方式： 安装了Istio-sidecar-injecor 12kubectl label namespace &lt;namespace&gt; istio-injection=enabledkubectl create -n &lt;namespace&gt; -f &lt;your-app-spec&gt;.yaml 没有安装Istio-sidecar-injecor 1kubectl create -f &lt;(istioctl kube-inject -f &lt;your-app-spec&gt;.yaml) 在这里我们部署samples里的bookinfo应用1kubectl label namespace bran istio-injection=enabled 1kubectl apply -f samples/bookinfo/kube/bookinfo.yaml -n bran 创建应用的ingress gateway1istioctl create -f samples/bookinfo/routing/bookinfo-gateway.yaml 其中在bookinfo-gateway.yaml的meta里面加了namesapce: bran 创建完成了可以看到 访问应用通过nodeport:ip/productpage访问bookinfo应用 多点几次，发现有不同的页面出现。应用用到了负载均衡]]></content>
      <categories>
        <category>ServiceMesh</category>
      </categories>
      <tags>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除私有仓库镜像]]></title>
    <url>%2F2018%2F07%2F08%2Fdelete-docker-image%2F</url>
    <content type="text"><![CDATA[对于私有仓库的镜像，我们无法直接删除。当随着镜像的越来越多，会导致磁盘空间越来越小 阅读registry v2的http API后发现删除镜像需要调用几个API 获取image的digest 删除镜像的manifests 下面是删除私有registry的镜像脚本clean.shUsage：bash clean.sh your-image-name 需要安装jq，jq是终端解析json输出的利器 12345678910111213141516171819202122232425#!/usr/bin/env bashACCEPT_HEADER="Accept: application/vnd.docker.distribution.manifest.v2+json"DOCKER_REGISTRY="your-registry:35000/v2"AUTH="-uusername:password"REPOSITORY=$1TAGS=`curl --silent -X GET -k $AUTH $DOCKER_REGISTRY/$REPOSITORY/tags/list | jq -r '."tags"[]'`echo image $REPOSITORY has tags: $TAGSfor TAG in $&#123;TAGS[@]&#125;do echo "i am going to delete $REPOSITORY:$TAG" digest_value=`curl -X GET -k --head --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" $AUTH $DOCKER_REGISTRY/$REPOSITORY/manifests/$TAG 2&gt;&amp;1 | grep Docker-Content-Digest | awk '&#123;print $2&#125;'` digest_url="$DOCKER_REGISTRY/$REPOSITORY/manifests/$digest_value" echo $digest_url URL=$&#123;digest_url%$'\r'&#125; curl -X DELETE -k -H "Accept: application/vnd.docker.distribution.manifest.v2+json" $AUTH $URLdone#docker exec -it registry bin/registry garbage-collect /etc/docker/registry/config.yml#REPOSITORY_PATH="/var/lib/registry/docker/registry/v2/repositories"#docker exec -it registry rm -rf $REPOSITORY_PATH/$REPOSITORY 脚本里面注释的几行需要解释一下： gc回收，我们删除image的mainfests的时候，仓库并不会删除image，只有当你调用GC回收的时候，才会删除。这个可以用crontab定时执行。 删除具体的镜像目录。（当我们用GC回收的时候，其实只是把镜像名字从仓库里面去掉了。但是实际上磁盘还是存在这个镜像的。这个只能是通过rm删除 结尾：这个脚本只是删除单一镜像。当然可以更进一步的封装，删除所有镜像等等]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用registry搭建docker私有仓库]]></title>
    <url>%2F2018%2F07%2F08%2Fbuild-docker-registry%2F</url>
    <content type="text"><![CDATA[准备目录首先在根目录下创建一个文件夹registry（取名随意），在registry目录下面创建三个文件夹data，auth，certs 设置registry的用户密码1docker run --rm --entrypoint htpasswd registry:2 -Bbn &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125; &gt; auth/htpasswd 生成证书文件1docker run --rm -e COMMON_NAME=pek2-office-9th-10-117-169-121.eng.vmware.com -e KEY_NAME=domain -v /root/registry/certs:/certs centurylink/openssl COMMON_NAME 是你的FQDN上面的命令执行完成，你会在/root/registry/certs目录下面生成三个文件：domain.crt, domain.csr, domain.key如果你遇到permission error， 有可能是selinux的问题，可以执行setenforce 0 运行registry1docker run -d --name registry -p 5000:5000 -v /root/registry/data:/var/lib/registry -v /root/registry/auth:/auth -v /root/registry/certs:/certs -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key -e "REGISTRY_AUTH=htpasswd" -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd registry:2 拷贝证书文件12mkdir -p /etc/docker/certs.d/pek2-office-9th-10-117-169-121.eng.vmware.com:5000cp /root/registry/certs/domain.crt /etc/docker/certs.d/pek2-office-9th-10-117-169-121.eng.vmware.com:5000 push镜像到私有Registry123docker login -u &#123;&#123;username&#125;&#125; -p &#123;&#123;password&#125;&#125; pek2-office-9th-10-117-169-121.eng.vmware.com:5000docker tag ubuntu pek2-office-9th-10-117-169-121.eng.vmware.com:5000/ubuntu:firstimagedocker push pek2-office-9th-10-117-169-121.eng.vmware.com:5000/ubuntu:firstimage 到此，我们搭建好了我们的私有仓库]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo集成Gitalk评论]]></title>
    <url>%2F2018%2F07%2F07%2Fhexo-next-gitalk%2F</url>
    <content type="text"><![CDATA[开端想在自己的博客系统里集成评论系统，到网上一搜。最后发现Gitalk评论系统用的人最多，受称赞比较多 Gitalk Demo: https://gitalk.github.io/ 注册GitHub Application在GitHub上注册新应用，链接：https://github.com/settings/applications/new 参数说明： Application name: # 应用名称，我的名称是hexo-nsxt-comments Homepage URL: # 网站URL，如https://branw.cn Application description: # 描述，随意 Authorization callback URL: # 网站URL，https://branw.cn 填写网站URL的时候，注意要填写你自己域名的网址，没有的话就写github.io网址，我在这个地方花了好多时间，最后写对了网址URL就成功了 注册完成后会得到ClientID, Client Secret，后面配置_config.yml的时候会用到 创建repo创建一个与应用名称一样的repo，用来存放评论例如：我的repo名字就是：hexo-nsxt-comments 配置Gitalk新建/layout/_third-party/comments/gitalk.swig文件，并添加内容：123456789101112131415161718192021&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125; &#123;% if theme.gitalk.enable %&#125; &#123;% if page.comments %&#125; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; const gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123;theme.gitalk.clientID&#125;&#125;&apos;, clientSecret: &apos;&#123;&#123;theme.gitalk.clientSecret&#125;&#125;&apos;, repo: &apos;&#123;&#123;theme.gitalk.repo&#125;&#125;&apos;, owner: &apos;&#123;&#123;theme.gitalk.owner&#125;&#125;&apos;, admin: &apos;&#123;&#123;theme.gitalk.admin&#125;&#125;&apos;.split(&apos;,&apos;), pagerDirection: &apos;&#123;&#123;theme.gitalk.pagerDirection&#125;&#125;&apos;, id: md5(window.location.pathname), distractionFreeMode: false &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt; &#123;% endif %&#125; &#123;% endif %&#125;&#123;% endif %&#125; 修改/layout/_partials/comments.swig123&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; 修改layout/_third-party/comments/index.swig，在最后一行添加内容：1&#123;% include &apos;gitalk.swig&apos; %&#125; 在主题配置文件next/_config.yml中添加如下内容：12345678gitalk: enable: true owner: onesafe repo: hexo-nsxt-comments clientID: xxxxxxxxx clientSecret: xxxxxxxxx admin: onesafe pagerDirection: last 授权最后一步了这时候打开博客，发现评论是空的，没有创建ISSUE如果我们前面的都配置成功的话，尤其是Authorization callback URL配置成功的话这时候我们只需要用admin账户登录GitHub授权就大功告成了 下面的图就是授权的过程，点击授权就OK了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平凡的生活]]></title>
    <url>%2F2018%2F07%2F06%2Fvivian-v%2F</url>
    <content type="text"><![CDATA[在我们短促而漫长的一生中，我们在苦苦地寻找人生的幸福。可幸福往往又与我们失之交臂。当我们为此而耗尽宝贵的青春年华，皱纹也悄悄地爬上了眼角的时候，我们或许才能懂得生活实际上意味着什么……]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作总结]]></title>
    <url>%2F2018%2F07%2F06%2Fwork-conclusion%2F</url>
    <content type="text"><![CDATA[我是5.10号入职现在的公司的，对我来说是一个全新的开始 5月-6月首先来是看service-manager的代码，之前对Java不熟，对我来说也是一个小小的挑战 也能够drive我很好的学习Java，感觉来了两个月，Java已经可以愉快的玩耍了 用spring-boot-starter-actuator做了service-manager的健康检查 参考service-manager写一个auto-model-online项目 image-hub的项目，是与镜像相关的 elf-bundled项目 在这个过程当中，结合写代码和看书，对Spring boot理解的更深刻了。学会使用Java Spring boot 异步，并发。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
</search>
